// Copyright (c) 2020 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"log"
	"os"
	"os/exec"
	"sort"
	"text/template"
)

type Group struct {
	Type  string
	Insns []Insn
}

type Insn struct {
	Opcode   uint32
	Mnemonic string
}

var insns = map[string][]Insn{
	"Imm16": {
		{0xd4<<24 | 1<<21 | 0<<2 | 0<<0, "BRK"},
	},

	"Imm26": {
		{0<<31 | 5<<26, "B"},
		{1<<31 | 5<<26, "BL"},
	},

	"CondImm19": {
		{0x2a<<25 | 0<<24 | 0<<4, "Bc"},
	},

	"Reg": {
		{0x6b<<25 | 0<<21 | 0x1f<<16 | 0<<10 | 0<<0, "BR"},
		{0x6b<<25 | 1<<21 | 0x1f<<16 | 0<<10 | 0<<0, "BLR"},
		{0x6b<<25 | 2<<21 | 0x1f<<16 | 0<<10 | 0<<0, "RET"},
	},

	"RegImm14Bit": {
		{0x1b<<25 | 0<<24, "TBZ"},
		{0x1b<<25 | 1<<24, "TBNZ"},
	},

	"RegImm16HwSf": {
		{0<<29 | 0x25<<23, "MOVN"},
		{2<<29 | 0x25<<23, "MOVZ"},
		{3<<29 | 0x25<<23, "MOVK"},
	},

	"RegImm19Imm2": {
		{0<<31 | 0x10<<24, "ADR"},
	},

	"RegImm19Size": {
		{0x1a<<25 | 0<<24, "CBZ"},
		{0x1a<<25 | 1<<24, "CBNZ"},
	},

	"RegRegImm3ExtRegSf": {
		{0<<30 | 0<<29 | 0x0b<<24 | 0<<22 | 1<<21, "ADDe"},
		{1<<30 | 1<<29 | 0x0b<<24 | 0<<22 | 1<<21, "SUBSe"},
	},

	"RegRegImm6Imm6NSf": {
		{2<<29 | 0x26<<23 | 0<<22, "UBFM"},
	},

	"RegRegImm6RegShiftSf": {
		{0<<30 | 0<<29 | 0x0b<<24 | 0<<21, "ADDs"},
		{1<<30 | 0<<29 | 0x0b<<24 | 0<<21, "SUBs"},
		{1<<30 | 1<<29 | 0x0b<<24 | 0<<21, "SUBSs"},
		{0<<29 | 0x0a<<24 | 0<<21, "ANDs"},
		{1<<29 | 0x0a<<24 | 0<<21, "ORRs"},
		{3<<29 | 0x0a<<24 | 0<<21, "ANDSs"},
	},

	"RegRegImm9Size": {
		{1<<31 | 7<<27 | 0<<24 | 1<<22 | 0<<21 | 1<<10, "LDRpost"},
		{1<<31 | 7<<27 | 0<<24 | 0<<22 | 0<<21 | 3<<10, "STRpre"},
		{1<<31 | 7<<27 | 0<<24 | 0<<22 | 0<<21 | 0<<10, "STUR"},
		{1<<31 | 7<<27 | 0<<24 | 1<<22 | 0<<21 | 0<<10, "LDUR"},
	},

	"RegRegImm12ShiftSf": {
		{0<<30 | 0<<29 | 0x11<<24, "ADDi"},
		{0<<30 | 1<<29 | 0x11<<24, "ADDSi"},
		{1<<30 | 0<<29 | 0x11<<24, "SUBi"},
		{1<<30 | 1<<29 | 0x11<<24, "SUBSi"},
	},

	"RegRegImm12Size": {
		{1<<31 | 7<<27 | 1<<24 | 0<<22, "STR"},
		{1<<31 | 7<<27 | 1<<24 | 1<<22, "LDR"},
	},

	"RegRegSf": {
		{1<<30 | 0<<29 | 0xd6<<21 | 0<<16 | 0<<10, "RBIT"},
		{1<<30 | 0<<29 | 0xd6<<21 | 0<<16 | 4<<10, "CLZ"},
	},

	"RegRegSOptionRegSize": {
		{1<<31 | 7<<27 | 0<<24 | 1<<22 | 1<<21 | 2<<10, "LDRr"},
	},

	"RegRegCondRegSf": {
		{0<<30 | 0<<29 | 0xd4<<21 | 0<<10, "CSEL"},
		{0<<30 | 0<<29 | 0xd4<<21 | 1<<10, "CSINC"},
	},

	"RegRegCondRegType": {
		{0<<31 | 0<<30 | 0<<29 | 0x1e<<24 | 1<<21 | 3<<10, "FCSEL"},
	},

	"RegRegType": {
		{0<<31 | 0<<30 | 0<<29 | 0x1e<<24 | 1<<21 | 0<<17 | 0<<15 | 0x10<<10, "FMOV"},
		{0<<31 | 0<<30 | 0<<29 | 0x1e<<24 | 1<<21 | 0<<17 | 2<<15 | 0x10<<10, "FNEG"},
	},

	"RegRegTypeSf": {
		{0<<30 | 0<<29 | 0x1e<<24 | 1<<21 | 0<<19 | 6<<16 | 0<<10, "FMOVtog"},
		{0<<30 | 0<<29 | 0x1e<<24 | 1<<21 | 0<<19 | 7<<16 | 0<<10, "FMOVfromg"},
	},

	"RegRegRegSf": {
		{0<<30 | 0<<29 | 0xd6<<21 | 0x0b<<10, "RORV"},
		{0<<30 | 0<<29 | 0xd6<<21 | 0x02<<10, "UDIV"},
		{0<<30 | 0<<29 | 0xd6<<21 | 0x03<<10, "SDIV"},
	},

	"RegRegRegRegSf": {
		{0<<29 | 0x1b<<24 | 0<<21 | 0<<15, "MADD"},
		{0<<29 | 0x1b<<24 | 0<<21 | 1<<15, "MSUB"},
	},

	"DiscardRegRegType": {
		{0<<31 | 0<<30 | 0<<29 | 0x1e<<24 | 1<<21 | 0<<14 | 8<<10 | 0<<3 | 0<<0, "FCMP"},
	},
}

func main() {
	var groups []Group
	for k, v := range insns {
		groups = append(groups, Group{k, v})
	}
	sort.Slice(groups, func(i, j int) bool { return groups[i].Type < groups[j].Type })

	generate(groups, "internal/isa/arm/in/insn_direct.gen.go", `
// +build !waginterp

package in

const ( {{range .}} {{$type := .Type}} {{range .Insns}}
{{.Mnemonic}} = {{$type}}({{printf "%#08x" .Opcode}}) {{end}}
{{end}} )
`)
}

func generate(input interface{}, filename string, tpl string) {
	tpl = "// Generated by internal/cmd/arm-in/generate.go.  DO NOT EDIT!\n\n" + tpl
	t := template.Must(template.New(filename).Parse(tpl))

	f, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	cmd := exec.Command("gofmt")
	cmd.Stdout = f
	cmd.Stderr = os.Stderr

	w, err := cmd.StdinPipe()
	if err != nil {
		log.Panic(err)
	}

	if err := cmd.Start(); err != nil {
		log.Fatal(err)
	}

	err = t.Execute(w, input)
	if err != nil {
		log.Panic(err)
	}

	if err := w.Close(); err != nil {
		log.Fatal(err)
	}

	if err := cmd.Wait(); err != nil {
		log.Fatal(err)
	}
}
